通过加入    内存屏障	和	禁止重排序	优化来实现

* 对volatile变量 写 操作时，会在写操作后加入一条store屏蔽指令，将本地内存中的共享变量值刷新到主内存

* 对volatile变量 读 操作时，会在读操作前加入一条load屏蔽指令，从主内存中读取共享变量

** volatile    不   具备原子性，例如
执行count++    ，1.线程从主存中读取变量值 2.变量+1 3.线程将变量值写回主存
可能的情况，两个线程分别读取到了变量的最新值，然后分别+1，依次volatile强制写入主存，但依然是存回了两个相同的变量值


*** volatile适用情形
1.对变量的写操作不依赖于当前值
2.该变量没有包含在具有其他变量的计算式中

适合做状态标识量（线程共享）
eg:
volatile boolean inited = false;

//线程1:
context = loadContext();//启动线程
inited = true;//修改状态标识

//线程2:
while(!inited){  //如果线程被启动
	sleep();//线程休眠
}

